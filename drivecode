package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
import org.firstinspires.ftc.robotcore.external.JavaUtil;

@TeleOp(name = "PowerPlayDC (Blocks to Java)")
public class Powerplaydc extends LinearOpMode {

  private DcMotor ArmMotor;
  private DcMotor Frontleft;
  private DcMotor Backleft;
  private DcMotor Frontright;
  private DcMotor Backright;
  private Servo GripperServo;

  /**
   * This function is executed when this Op Mode is selected from the Driver Station.
   */
  @Override
  public void runOpMode() {
    boolean goToPosition;
    int lowJunction;
    int mediumJunction;
    int highJunction;
    int positionHome;
    int coneHeight;
    double maxPower;
    double y;
    double x;
    double rx;
    double denominator;

    ArmMotor = hardwareMap.get(DcMotor.class, "ArmMotor");
    Frontleft = hardwareMap.get(DcMotor.class, "Frontleft");
    Backleft = hardwareMap.get(DcMotor.class, "Backleft");
    Frontright = hardwareMap.get(DcMotor.class, "Frontright");
    Backright = hardwareMap.get(DcMotor.class, "Backright");
    GripperServo = hardwareMap.get(Servo.class, "GripperServo");

    ArmMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    ArmMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    ArmMotor.setDirection(DcMotorSimple.Direction.REVERSE);
    ArmMotor.setTargetPosition(0);
    ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    goToPosition = false;
    lowJunction = 1700;
    mediumJunction = 2800;
    highJunction = 3800;
    positionHome = 0;
    coneHeight = 750;
    maxPower = 0.7;
    waitForStart();
    if (opModeIsActive()) {
      // Reverse the left side motors for the drive code
      Frontleft.setDirection(DcMotorSimple.Direction.REVERSE);
      Backleft.setDirection(DcMotorSimple.Direction.REVERSE);
      while (opModeIsActive()) {
        // Drive Code
        y = -SlowStart.smoothCube(gamepad1.left_stick_y);
        x = SlowStart.smoothCube(gamepad1.left_stick_x);
        // Counteract imperfect strafing
        rx = gamepad1.right_stick_x * 1.1;
        // Denominator is the largest motor power
        // (absolute value) or 1.
        // This ensures all the powers maintain
        // the same ratio, but only when at least one is
        // out of range [-1, 1].
        denominator = JavaUtil.maxOfList(JavaUtil.createListWith(JavaUtil.sumOfList(JavaUtil.createListWith(Math.abs(y), Math.abs(x), Math.abs(rx))), 1));
        // Make sure your ID's match your configuration
        Frontleft.setPower(((y + x + rx) / denominator) * maxPower);
        Backleft.setPower((((y - x) + rx) / denominator) * maxPower);
        Frontright.setPower((((y - x) - rx) / denominator) * maxPower);
        Backright.setPower((((y + x) - rx) / denominator) * maxPower);
        // Arm Code
        if (gamepad2.dpad_down) {
          ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + -100);
          ArmMotor.setPower(1);
        }
        if (gamepad2.dpad_up) {
          ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + 100);
          ArmMotor.setPower(1);
        }
        if (gamepad2.a) {
          while (gamepad2.a) {
          }
          if (ArmMotor.getCurrentPosition() > 3 && GripperServo.getPosition() == 0) {
            ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + (lowJunction - ArmMotor.getCurrentPosition()));
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(1);
          } else {
            ArmMotor.setTargetPosition(positionHome);
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(0.8);
          }
          goToPosition = true;
        }
        if (gamepad2.b) {
          while (gamepad2.b) {
          }
          if (ArmMotor.getCurrentPosition() > 3 && GripperServo.getPosition() == 0) {
            ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + (mediumJunction - ArmMotor.getCurrentPosition()));
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(1);
          } else {
            ArmMotor.setTargetPosition(positionHome);
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(0.8);
          }
          goToPosition = true;
        }
        if (gamepad2.y) {
          while (gamepad2.y) {
          }
          if (ArmMotor.getCurrentPosition() > 3 && GripperServo.getPosition() == 0) {
            ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + (highJunction - ArmMotor.getCurrentPosition()));
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(1);
          } else {
            ArmMotor.setTargetPosition(positionHome);
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(0.8);
          }
          goToPosition = true;
        }
        if (gamepad2.x) {
          while (gamepad2.x) {
            ArmMotor.setTargetPosition(positionHome);
            ArmMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            ArmMotor.setPower(0.8);
          }
          goToPosition = true;
        }
        // Gripper Code
        if (gamepad2.left_bumper) {
          GripperServo.setPosition(0);
          sleep(100);
          ArmMotor.setTargetPosition(ArmMotor.getCurrentPosition() + coneHeight);
          ArmMotor.setPower(1);
        }
        if (gamepad2.right_bumper) {
          GripperServo.setPosition(0.71);
        }
        telemetry.addData("Ticks", ArmMotor.getCurrentPosition());
        telemetry.addData("key", GripperServo.getPosition());
        telemetry.update();
      }
    }
  }
}
